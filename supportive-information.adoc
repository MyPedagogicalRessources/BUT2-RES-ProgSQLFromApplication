= Programmation SQL depuis une application PHP
:author: Franck Silvestre
:icons: font
:toc: left
:sectnums:

ifdef::backend-html5,env-github[]
++++
include::licence.html[]
++++
endif::[]

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Introduction

=== Liens utils

- http://php.net/manual/fr/book.pdo.php 
- https://phpdelusions.net/pdo 

=== PDO - PHP _Data Objects_

* Couche d’abstraction d’accès à la base de données
** Interface unifiée pour un accès à différentes bases de données (BDD)
** MySQL, PostgreSQL, Oracle, MS SQL Server, etc.

* Bénéfices
** sécurité : énoncés préparés (prepared statements) 
** utilisabilité : fonctions d’automatisation des opérations routinières

* PDO vs librairies ORM
** PDO n’est pas un outil d’ORM
** PDO s’appuie sur SQL
** PDO est plutôt l’équivalent de JDBC en Java

== Se connecter à la base

=== Le _data source name_

* Fourniture d’un Data Source Name (DSN) pour accéder à la base de données (BDD)

* Le DSN encapsule dans une chaîne de caractère les informations relatives…
** au _driver_ (pilote) de la BDD
** au host (nom ou adresse du serveur hébergeant la BDD)
** au nom du schema (nom de la BDD)
** au jeu de caractère utilisé (charset)
** et si nécessaire, le port d’écoute, l’identifiant de la socket unix 

* Format type d’un DSN à travers un exemple

[source,php]
----
    $dsn = "mysql:host=localhost;dbname=MyActivities;port=8889;charset=utf8" <1>
----
<1> L'identification du pilote de la BDD suivi du caractère "*:*". Puis les paires clés-valeurs sont séparées par le caractère "*;*". 

=== Les éléments d’authentification et autres options

* Fourniture d’un nom d’utilisateur et d’un mot de passe
* Autres options dans un tableau associatif
* Tous les éléments de spécifications servent à la construction d’un objet de type PDO

=== Exemple

[source,php]
----
$host = 'localhost';
$db = 'my_activities';
$user = 'root';
$pass = 'root';
$charset = 'utf8mb4';

$dsn = "mysql:host=$host;dbname=$db;charset=$charset"; <1>

$options = [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES => false,
]; <2>

try {
    $pdo = new PDO($dsn, $user, $pass, $options); <3>
} catch (PDOException $e) {
    throw new PDOException($e->getMessage(), (int)$e->getCode());
}
----
<1> Création du _data source name_
<2> Spécifications complémentaires de la connexion dans un tableau associatif
<3> Création de l'objet PDO encapsulant le canal de connexion à la BDD **dans un block `try...catch`**

[WARNING]
====
L’ouverture d’une connexion à la base est très couteuse.

* Nécessite de minimiser le nombre d’ouvertures de connexions
* Nécessite de passer l’objet de type PDO en paramètre des fonctions effectuant les accès à la base.
==== 

== Exécuter des requêtes sans paramètre

=== PDO::query()

* À utiliser pour des requêtes sans paramètre
** exemple de requête : "SELECT email FROM users"
* Retourne un objet de type PDOStatement 
* Extraction des lignes à partir du PDOStatement retourné
* Exemple

[source, php]
----
$stmt = $pdo->query('SELECT email FROM users'); <1>
while ($row = $stmt->fetch()) <2>
{
    echo $row['email'] . "\n"; <3>
}
----
<1> Création de l'objet statement à partir de l'énoncé SQL
<2> La méthode `fetch()` permet de récupérer la prochaine ligne du résultat de la requête dans un tableau associatif.
<3> Les clés du tableau correspondent aux noms des colonnes spécifiées dans la requête SQL.

== Exécuter des requêtes avec paramètres

=== Prepared statements

* Protection contre les attaques de type « injection de SQL »

IMPORTANT: lire https://phpdelusions.net/sql_injection 

* Mode opératoire
** Utilisation de places réservées (place holder) dans l’énoncé de la requête pour passer les valeurs des paramètres.
** Préparation de l’énoncé.
** Exécution de la requête en fournissant les valeurs des paramètres via un objet dédié (tableau ou tableau associatif).

=== Exemple - Utilisation des espaces réservés

==== Espaces réservés identifiés par la position

[source, php]
----
$sql = 'SELECT * FROM users WHERE email = ? AND status=?'; <1>
----
<1> les points d'interrogation indiquent la position des paramètres

==== Espaces réservés nommés

[source, php]
----
$sql = 'SELECT * FROM users WHERE email = :email AND status=:status'; <1>
----
<1> les identifiants des paramètres sont préfixés par le caractère "*:*"

==== L'attrape débutant 

[WARNING]
==== 
Ne pas construire un énoncé comme cela :

[source, php]
----
$sql = "SELECT * FROM users WHERE email = '$email' AND status='$status'"; <1>
----
<1> Cette approche est perméable aux attaques par injection de code dans les variables.
====

=== Préparation de l’énoncé

* Appel de la méthode `PDO::prepare()`
* Retourne un objet de type `PDOStatement`  qui n’est attaché à aucun résultat à ce stade
* Appel de la méthode `PDOStatement::execute()` pour exécuter la requête en prenant en paramètre les valeurs des espaces réservés

=== Exemples

==== Avec espaces réservés positionnels

[source, php]
----
$stmt = $pdo->prepare('SELECT * FROM users WHERE email = ? AND status=?'); <1>
$stmt->execute([$email, $status]); <2>
$user = $stmt->fetch(); <3>
----
<1> Création du _statement_ préparé
<2> Passage d'un *tableau* en paramètre de la méthode `execute`
<3> Accès à la prochaine ligne du résultat de la requête

==== Avec espaces réservés nommés

[source, php]
----
$stmt = $pdo->prepare(‘SELECT * FROM users WHERE email = :email AND status=:status'); 
$stmt->execute(['email' => $email, 'status' => $status]); <1>
$user = $stmt->fetch(); 
----
<1> Passage d'un *tableau associatif* en paramètre de la méthode `execute`


=== Attachement avec explicitation des types

* Les types sont inférés par défaut au moment de l’éxécution.
* Parfois, il est nécessaire d’expliciter la correspondance de type entre les variables utilisées et les paramètres de l’énoncé préparé

[NOTE]
====
À Lire 

* http://php.net/manual/en/pdostatement.bindvalue.php
* http://php.net/manual/en/pdostatement.bindparam.php 
==== 

=== Exécution multiple

* Possibilité de recycler un énoncé préparé pour plusieurs exécutions
* Exemple

[source, php]
----
$data = [
    1 => 15,
    5 =>  18,
    9 =>  12,
];
$stmt = $pdo->prepare ('UPDATE users SET grade = grade + ? WHERE id = ?'); <1>
foreach ($data as $id => $grade)
{
    $stmt->execute([$grade, $id]);<2>
}  
----
<1> Une seule préparation, un seul _statement_ créé
<2> Le même _statement_ est réutilisé à chaque itération

=== INSERT, UPDATE ou DELETE

* L’utilisation des énoncés préparés (ou non) s’appliquent

[source, php]
----
$sql = "UPDATE users SET name = ? WHERE id = ?";
$pdo->prepare($sql)->execute([$name, $id]);
----

* Possibilité de récupérer le nombre de lignes affectées

[source, php]
----
$stmt = $pdo->prepare("DELETE FROM books WHERE category = ?");
$stmt->execute([$category]);
$count_deleted = $stmt->rowCount(); <1>
----
<1> La méthode `rowCount()` permet de récupérer le nombre de lignes affectées par la requête.

=== Mode « émulation » vs mode « natif »

.Rappel 
[source, php]
----
$host = 'localhost';
$db   = ‘my-activities’;
$user = 'root';
$pass = 'root';
$charset = ‘utf8mb4';

$dsn = "mysql:host=$host;dbname=$db;charset=$charset";
$options = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES   => false, <1>
]; 
try {
     $pdo = new PDO($dsn, $user, $pass, $options);
} catch (PDOException $e) {
     throw new PDOException($e->getMessage(), (int)$e->getCode());
}
----
<1> Parmètre pour spécifier *qui* effectue la préparation.

[source, php]
----
PDO::ATTR_EMULATE_PREPARES   => false 
----

* Résolution de l’énoncé préparé par la base de données
* 2 allers-retours : 1 pour l’énoncé et 1 pour les données

[source, php]
----
PDO::ATTR_EMULATE_PREPARES   => true # par défaut
---- 

* Résolution de l’énoncé préparé par PDO (dans l’application)
* 1 aller-retour envoyant la requête SQL « finale »

== Transactions et auto-commit

=== Rappel transaction

Encapsulation d’une succession d’opérations SQL de manière ACID

* Atomique (Atomicity)
* Cohérente (Consistency)
* Isolée (Isolation)
* Durable (Durability)

=== Transactions vs Autocommit

* Auto-commit
** Chaque requête encapsulée dans une transaction
* Transactions
** Nécessaire si besoin d’encapsuler plusieurs opérations
** Méthodes impliquées
*** `PDO::beginTransaction()` pour initier la transaction
*** `PDO::commit()` ou `PDO::rollBack()` pour finir la transaction

WARNING: Certaines systèmes de gestion de bases de données ne supportent pas la gestion des transactions (mais MySql oui)! 

=== Exemple

[source, php]
----
try {
    $pdo->beginTransaction(); <1>
    $stmt = $pdo->prepare("INSERT INTO users (name) VALUES (?)");
    foreach (['Lisa','Frederic'] as $name)
    {
        $stmt->execute([$name]);
    }
    $pdo->commit(); <2>
}catch (Exception $e){
    $pdo->rollBack(); <3>
    throw $e;
}
----
<1> Ouverture de la transaction
<2> Marque la fin de la transaction en cours pour rendre ses changements permanents.
<3> Annule la transaction en cours, en annulant toutes ses modifications.

IMPORTANT: Ne pas oublier le rollBack en cas de problème pour rétablir la base dans son état cohérent d’avant la transaction !

== La gestion des erreurs

=== Configurer la gestion des erreurs

Rappel...

[source, php]
----
$host = 'localhost';
$db   = ‘my-activities’;
$user = 'root';
$pass = 'root';
$charset = ‘utf8mb4';

$dsn = "mysql:host=$host;dbname=$db;charset=$charset";
$options = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION, <1>
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES   => false,
];
try {
     $pdo = new PDO($dsn, $user, $pass, $options);
} catch (PDOException $e) {
     throw new PDOException($e->getMessage(), (int)$e->getCode());
}
----
<1> Attribut permettant de spécifier le mode de gestion d'erreurs

=== Trois stratégies de gestion d'erreurs

* `PDO::ERRMODE_SILENT`
** Mise à jour des objets PDOStatement et PDO concernés avec les informations concernant l’erreur
** Utilisation respectivement des méthodes `PDOStatement::errorCode()`, `PDOStatement::infoCode()` et `PDO::errorCode()`, `PDO::infoCode()`` pour récupérer l’information
* `PDO::ERRMODE_WARNING`
** `PDO::ERRMODE_SILENT` + émission d’un message `E_WARNING`
** Utile en phase de débguage/test
* `PDO::ERRMODE_EXCEPTION`
** `PDO::ERRMODE_SILENT` + lever d’une `PDOException` décrivant l’erreur (code et information)
** Gestion plus fine des erreurs ; gestion élégante des erreurs liées aux transactions (rollBack dans le bloc catch)

=== Exemple 

[source, php]
----
try {
    $pdo->beginTransaction();
    $stmt = $pdo->prepare("INSERT INTO users (name) VALUES (?)");
    foreach (['Lisa','Frederic'] as $name)
    {
        $stmt->execute([$name]);
    }
    $pdo->commit();
}catch (Exception $e){
    $pdo->rollBack(); <1>
    throw $e;
}
----
<1> Le mode `PDO::ERRMODE_EXCEPTION` permet de gérer proprement une erreur liée à la BDD en déclenchant un `rollBack()` dans le bloc `catch`.

== Fermer la connexion à la base

=== Fermeture implicite

PHP clotûre automatiquement la connexion à la BDD à la fin du script.

=== Fermeture explicite

* L’objet PDO doit être détruit
* Assigner null à toutes les variables référençant l’objet de manière directe ou indirecte.

[source, php]
----
$stmt = $pdo-prepare(‘SELECT * FROM users WHERE email = :email AND status=:status');
$stmt->execute(['email' => $email, 'status' => $status]);
$user = $stmt->fetch();

$stmt = null; <1>
$pdo = null; <2>
----
<1> l'objet _statement_ référence l'objet PDO ayant servi à établir la connexion. Il est donc nécessaire de positionner la référence au _statement_ à null pour qu'il soit détruit et ne référence plus son PDO.
<2> La référence au PDO est positionnée à null.

=== Connexion persistente

* Possibilité de configurer une connexion pour qu’elle soit réutilisée par plusieurs scripts.
* Dans le tableau des options de configuration...

[source, php]
----
$options = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES   => false,
    PDO::ATTR_PERSISTENT => true <1>
];
----
<1> Bénéfice assurée en terme de performance : ouvrir une nouvelle connexion à une base de données est très couteux en comparaison de la réutilisation d'une connexion déjà ouverte !